<!DOCTYPE html>
<html>
    <head>
      <title>Assignment03</title>
    </head>
    <body>
      <h1>Prachod Elisetti</h1>
    </body>
    <head1>
     <title1>Taj mahal</title1>
  </head1>
     <body1>
     <p> 
      Image result for taj mahal agra short story
      The dead body of Mumtaz has placed at the Banks of <b>River Yamuna</b>. 
      As he <b>promised</b> he constructed the Taj Mahal over her grave
     </p>
     <hr>
    <h3>DIRECTIONS FROM MARYVILLE TO TAJ MAHAL</h3>
    <ol>
        <li>Travel From Maryville to my favourite place
        <ol>
            <li>By Cab from Maryville to Kansas City</li>
            <li>By Flight from Kansas City to newyork</li>
            <li>By Flight from newyork to Delhi</li>
            <li>By car from Delhi to agra </li>
            <li>By car agra to Taj mahal </li>
        </ol>
        </li>
        <li>Finally reached to my favourite  Taj mahal</li>
        </ol>
        <ul>
          <li>seeing movies</li>
          <li>headsetS</li>
          <li>food</li>
          <li>Clothes</li>
        </ul>
    </body1>
    <a href=https://github.com/44-563-WebApps-F21/webapps-f21-assignment-3-Prachodd/blob/main/Aboutme.html>Aboutme</a>
<hr>
    <h4>FOOD DISHES</h4>
    <p>Food Items that I would recommend one to try and the cost that one should afford for each item in respective places.</p>
 <table>
     <tr>
         <th>Food Item</th>
         <th>Place</th>
         <th>Cost</th>
     </tr>
     <tr>
         <td> chicken Biryani</td>
         <td>Hyderabad</td>
         <td>$5</td>
     </tr>
     <tr>
         <td>Pani Puri</td>
         <td>Kolkata</td>
         <td>$6</td>
     </tr>
     <tr>
         <td>Dosa</td>
         <td>Banglore</td>
         <td>$4</td>
     </tr>
 </table>
</hr>
<hr>
<h4>Dynamic Programming</h4>
<blockquote><q>Dynamic Programming is mainly an optimization over plain recursion.
   Wherever we see a recursive solution that has repeated calls for same inputs, we can optimize it using Dynamic Programming. 
</q></blockquote>
<a href=https://www.geeksforgeeks.org/dynamic-programming/ >source link for definition</a><br>
<pre>
```
int m, n;
vector<long long> dp_before(n), dp_cur(n);

long long C(int i, int j);

// compute dp_cur[l], ... dp_cur[r] (inclusive)
void compute(int l, int r, int optl, int optr) {
    if (l > r)
        return;

    int mid = (l + r) >> 1;
    pair<long long, int> best = {LLONG_MAX, -1};

    for (int k = optl; k <= min(mid, optr); k++) {
        best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});
    }

    dp_cur[mid] = best.first;
    int opt = best.second;

    compute(l, mid - 1, optl, opt);
    compute(mid + 1, r, opt, optr);
}

int solve() {
    for (int i = 0; i < n; i++)
        dp_before[i] = C(0, i);

    for (int i = 1; i < m; i++) {
        compute(0, n - 1, 0, n - 1);
        dp_before = dp_cur;
    }

    return dp_before[n - 1];
}
```
</pre>
<br>
<a href=https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html>source link for code </a>
</hr>
</head>
</html>  
